Need a tool for converting RGB images to CMYK.

Needs to be able to store conversion presets.  The presets will have names, and be presented in a "SimpleCombo":

ConfigTemplate ConversionPreset::Template[]=
{
	ConfigTemplate("Description",""),
	ConfigTemplate("InProfile",""),
	ConfigTemplate("OutProfile",""),
	ConfigTemplate("Intent",""),
	ConfigTemplate("HoldBlack",int(0)),
	ConfigTemplate("HoldGrey",int(0)),
	ConfigTemplate("Overprint",int(0)),
	ConfigTemplate()
};

These options will be saved in $XDG_CONFIG_HOME/cmyktool/
On startup this directory will be scanned, and each file loaded in turn into a dummy ConfigDB
from which the description will be extracted.
|(Can SimpleComboOption be changed so instead of a static array it builds a list?)

| SimpleComboOptions opts;
| opts.add("Shortname",_("User-visible name"));
| opts.add(...
| The list must be copied for the widget - otherwise a constructing function can't safely use a local SimpleComboOptions.



Also need a ConversionOptions object - something which can be passed around and copied.

enum CMYKConversionType
{
	CMYKCONVERSIONTYPE_NORMAL,
	CMYKCONVERSIONTYPE_HOLDBLACK,
	CMYKCONVERSIONTYPE_HOLDGREY,
	CMYKCONVERSIONTYPE_OVERPRINT,
};

class CMYKConversionOptions
{
	public:
	CMYKConversionOptions(const char *presetname=NULL);
	CMYKConversionOptions(const CMYKConversionOptions &other);
	~CMYKConversionOptions();
	CMYKConversionOptions &operator=(const CMYKConversionOptions &other);

	LCMSWrapper_Intent GetIntent();
	CMYKConversionMode GetMode();
	const char *GetInProfile();
	const char *GetOutProfile();

	void SetIntent(LCMSWrapper_Intent intent);
	void SetMode(CMYKConversionMode mode);
	void SetInProfile(const char *in);
	void SetOutProfile(const char *out);

	Save(const char *presetname);

	ImageSource *Apply(ImageSource *src,ImageSource *mask=NULL);

	protected:
	char *inprofile;
	char *outprofile;
	LCMSWrapper_Intent intent;
	CMYKConversionMode mode;
};


The UI would have a panel on the left containing the list of files to be processed, then a notebook.
The first page of the notebook will contain a drop-down with the list of presets, the last of which will be "New..."
When a preset is selected, the values from that preset will be loaded into the widgets beneath the combo.
Any change to these values must change the Combo's value to "New..." (Or maybe just make a "Save" button sensitive.)

Need a better solution for the channel selectors - maybe a row of togglebuttons each with the squiggle icon
in a different colour.  -  or maybe checkboxes with a coloured squiggle as a label?
The widgets beneath will allow In and Out profiles to be selected, along with a rendering intent.
If the Out profile is CMYK, a combo box with the following options will be available:
Normal
Hold Black
Hold Grey
Overprint Black

The second pane of the notebook will contain a preview of the original image.
| The third pane of the notebook will contain a preview of the converted file.
| This will need a cached version of the transformed CMYK data, because we will need checkboxes
| for C, M, Y and K, so the plates can be dropped out for inspection of the result.

Also needs to support converting from CMYK to RGB.

| Need to improve support for GhostScript backend.  Colourspace can be set using the input profile's colourspace.
| Temp files?  Lifetimes?  Multiple pages?

Need to separate rendering and temp file tracking.

| Need an ImageBuffer of some kind - something that can hold an image for further processing.


| Need to support multi-selection in the ImageSelector!


-------------------------------------

PSRip

Tool needs to allow a PS File to be dragged and dropped, or selected from a menu.  When a PS file is opened, a dialog
will pop up asking for RIP options - which amounts to:

* B/w, Grey, RGB or CMYK rendering.
* Resolution
* Text anti-aliasing (generally turned off) -dTextAlphaBits=4
* Graphics anti-aliasing (generally turned on) -dGraphicsAlphaBits=4

------------------------------------------

Need to consider thread pooling.  If you select a dozen images at once, you don't want to be running them all simultaneously.

| Perhaps some mutex-variation which uses a counter, similar to the RWMutex - would allow n threads to hold it at once,
| but make any further threads wait until the counter had diminished again.  (Multex)

| Better would be a work queue, and a small number of worker threads.
| Better, track worker threads and re-use them.  Requires message passing mechanism.  ThreadEvents? (Used Mutexes)

| Make SearchPath thread-safe.  (Needs a perseparate iterator which tracks open directories.)

Need a way of handling job deletion - needs to be tracked by the UITab, but has to be able to self-delete, too.
Will have to be mutex-protected.  Reference counting?
The scenario that causes the problem is this:
If the main thread queues a job A, which references object B, it's possible for the main thread to delete
B before job A is run, and there's no way, currently, of robustly cancelling job A.
The most elegant solution to this is probably to build a second queue, so there's a waiting and a running queue, then
provide a Cancel() method to the jobdispatcher which takes a Job pointer as an argument.
The dispatcher will then search both queues, and if found, delete the job.  If the job is not found in either queue, then 
it's either finished and self-destructed, or about to be so.

