Need a tool for converting RGB images to CMYK.

Needs to be able to store conversion presets.  The presets will have names, and be presented in a "SimpleCombo":

ConfigTemplate ConversionPreset::Template[]=
{
	ConfigTemplate("Description",""),
	ConfigTemplate("InProfile",""),
	ConfigTemplate("OutProfile",""),
	ConfigTemplate("Intent",""),
	ConfigTemplate("HoldBlack",int(0)),
	ConfigTemplate("HoldGrey",int(0)),
	ConfigTemplate("Overprint",int(0)),
	ConfigTemplate()
};

These options will be saved in $XDG_CONFIG_HOME/cmyktool/
On startup this directory will be scanned, and each file loaded in turn into a dummy ConfigDB
from which the description will be extracted.
|(Can SimpleComboOption be changed so instead of a static array it builds a list?)

| SimpleComboOptions opts;
| opts.add("Shortname",_("User-visible name"));
| opts.add(...
| The list must be copied for the widget - otherwise a constructing function can't safely use a local SimpleComboOptions.


| Need a "core" object which will contain paths for colour profiles and other miscellaneous settings.

Need menus,
| and a dialog for setting core options.


| Also need a ConversionOptions object - something which can be passed around and copied.


| Need a better solution for the channel selectors - maybe a row of togglebuttons each with the squiggle icon
| in a different colour.  -  or maybe checkboxes with a coloured squiggle as a label?


The second pane of the notebook will contain a preview of the original image.
| The third pane of the notebook will contain a preview of the converted file.
| This will need a cached version of the transformed CMYK data, because we will need checkboxes
| for C, M, Y and K, so the plates can be dropped out for inspection of the result.

| Also needs to support converting from CMYK to RGB.

| Need to improve support for GhostScript backend.  Colourspace can be set using the input profile's colourspace.
| Temp files?  Lifetimes?  Multiple pages?

Need to separate rendering and temp file tracking.

| Need an ImageBuffer of some kind - something that can hold an image for further processing.


| Need to support multi-selection in the ImageSelector!


-------------------------------------

PSRip

Tool needs to allow a PS File to be dragged and dropped, or selected from a menu.  When a PS file is opened, a dialog
will pop up asking for RIP options - which amounts to:

* B/w, Grey, RGB or CMYK rendering.
* Resolution
* Text anti-aliasing (generally turned off) -dTextAlphaBits=4
* Graphics anti-aliasing (generally turned on) -dGraphicsAlphaBits=4

------------------------------------------

| Need to consider thread pooling.  If you select a dozen images at once, you don't want to be running them all simultaneously.

| Perhaps some mutex-variation which uses a counter, similar to the RWMutex - would allow n threads to hold it at once,
| but make any further threads wait until the counter had diminished again.  (Multex)

| Better would be a work queue, and a small number of worker threads.
| Better, track worker threads and re-use them.  Requires message passing mechanism.  ThreadEvents? (Used Mutexes)

| Make SearchPath thread-safe.  (Needs a perseparate iterator which tracks open directories.)

| Need a way of handling job deletion - needs to be tracked by the UITab, but has to be able to self-delete, too.
| Will have to be mutex-protected.  Reference counting?
| The scenario that causes the problem is this:
| If the main thread queues a job A, which references object B, it's possible for the main thread to delete
| B before job A is run, and there's no way, currently, of robustly cancelling job A.
| The most elegant solution to this is probably to build a second queue, so there's a waiting and a running queue, then
| provide a Cancel() method to the jobdispatcher which takes a Job pointer as an argument.
| The dispatcher will then search both queues, and if found, delete the job.  If the job is not found in either queue, then 
| it's either finished and self-destructed, or about to be so.

| Needs to be possible to interrupt redraw if the selected colorants changes.

--------------------

| Error message handling

| Needs to be some way of propogating error messages to the main thread for display to the user.
| It's not safe on Win32 for subthreads to pop up dialogs, so such a task must be deferred to the main
| thread by means of an idle/timeout handler.

| Need to maintain a queue of error messages.  It should be possible to merge them into a single message and display
| them in a single dialog - adding them to an existing dialog if it's open.

| Error message display code will be implemented as a global instance which will be informed of the top-level window
| when the program initializes - thus eliminating the need to pass around a parent window handle.

| Add support to pixbufview for page flipping.  This will allow imagetarget functionality to be folded into cmyktool.
| (Would use "normal", "normal proof" and "devicelink" optiosn on a combo, so they could be swapped with the mousewheel.)
| Will need to store a list of pixbufs, and have support for setting a page number.
| pixbufview_set_image() will clear the image list, and set the provided image as a first page.
| pixbufview_add_page(PixbufView *pb,GdkPixbuf *pb);
| pixbufview_set_page(PixbufView *pb,int page);
| pixbufview_clear_pages(PixbufView *pb);

