Need a tool for converting RGB images to CMYK.

Needs to be able to store conversion presets.  The presets will have names, and be presented in a "SimpleCombo":

ConfigTemplate ConversionPreset::Template[]=
{
	ConfigTemplate("Description",""),
	ConfigTemplate("InProfile",""),
	ConfigTemplate("OutProfile",""),
	ConfigTemplate("Intent",""),
	ConfigTemplate("HoldBlack",int(0)),
	ConfigTemplate("HoldGrey",int(0)),
	ConfigTemplate("Overprint",int(0)),
	ConfigTemplate()
};

These options will be saved in $XDG_CONFIG_HOME/cmyktool/
On startup this directory will be scanned, and each file loaded in turn into a dummy ConfigDB
from which the description will be extracted.
(Can SimpleComboOption be changed so instead of a static array it builds a list?)

| SimpleComboOptions opts;
| opts.add("Shortname",_("User-visible name"));
| opts.add(...
| The list must be copied for the widget - otherwise a constructing function can't safely use a local SimpleComboOptions.

The UI would have a panel on the left containing the list of files to be processed, then a notebook.
The first page of the notebook will contain a drop-down with the list of presets, the last of which will be "New..."
When a preset is selected, the values from that preset will be loaded into the widgets beneath the combo.
Any change to these values must change the Combo's value to "New..."

The widgets beneath will allow In and Out profiles to be selected, along with a rendering intent.
If the Out profile is CMYK, a combo box with the following options will be available:
Normal
Hold Black
Hold Grey
Overprint Black

The second pane of the notebook will contain a preview of the original image.
The third pane of the notebook will contain a preview of the converted file.
This will need a cached version of the transformed CMYK data, because we will need checkboxes
for C, M, Y and K, so the plates can be dropped out for inspection of the result.

Also needs to support converting from CMYK to RGB.

| Need to improve support for GhostScript backend.  Colourspace can be set using the input profile's colourspace.
| Temp files?  Lifetimes?  Multiple pages?

Need to separate rendering and temp file tracking.

Need an ImageBuffer of some kind - something that can hold an image for further processing.

// CachedImage_Deferred - the base class for cached images.  Sets up the width, height, type, etc.
// and allocated storage, but doesn't actually read the data from the ImageSource until asked.
// ReadImage() reads and caches the entire image.
// ReadRow() reads and caches a single row.
// Generally you won't use this except with ImageSource_Tee.

CachedImage_Deferred
{
	public:
	CachedImage_Deferred(ImageSource *source);
	~CachedImage_Deferred();
	void ReadImage();
	void ReadRow(int row);
	ImageSource_Cache *GetImageSource();
	protected:
	int width,int height;
	int samplesperpixel;
	IS_TYPE type;
	ISDataType *imagedata;
	friend class ImageSource_Cache;
	friend class ImageSource_Tee;
};


// Convenience subclass, this variant completely builds and processes the Cached Image immediately.

CachedImage : public CachedImage_Deferred
{
	public:
	CachedImage(ImageSource *source)
	{
		ReadImage();
	}
	~CachedImage()
	{
	}
	protected:
};


// The GetImageSource member function of the CachedImage classes will return one of these.
// Unlike most imagesources, this one claims no ownership of the source data, so you can 
// have as many operating concurrently and as many times on the Cached image as you like.

ImageSource_Cache
{
	public:
	ImageSource_Cache(CachedImage *img);
	~ImageSource_Cache();
	ISDataType *GetRow(int row);
	protected:
	CachedImage;
};


-------------------------------------

PSRip

Tool needs to allow a PS File to be dragged and dropped, or selected from a menu.  When a PS file is opened, a dialog
will pop up asking for RIP options - which amounts to:

* B/w, Grey, RGB or CMYK rendering.
* Resolution
* Text anti-aliasing (generally turned off) -dTextAlphaBits=4
* Graphics anti-aliasing (generally turned on) -dGraphicsAlphaBits=4



